"""
This module contains the necessary components to invalidate email verifications.

Email verifications expire after a set amount of time specified in the settings
(EMAIL_VERIFICATION_EXPIRATION_PERIOD). After expiration the user is automatically
logged out and a new verification email is sent out.
"""
from datetime import datetime

from allauth.account.adapter import DefaultAccountAdapter, get_adapter
from allauth.account.forms import LoginForm, SignupForm
from allauth.account.models import EmailAddress
from allauth.account.utils import perform_login
from django import forms
from django.conf import settings
from django.contrib import messages
from django.utils.deprecation import MiddlewareMixin

_EMAIL_VERIFICATION_CHECK_DATE_KEY = 'email_verification_check_date'

_EXCLUDED_VERIFICATION_PATHS = [
    '/media',
    '/static',
    '/accounts/logout',
    '/accounts/login'
]

_SWEDISH_USER_HELP_TEXT = '<strong>IMPORTANT:</strong> By specifying that you are a Swedish user your acount will ' \
                          'be put through a manual verification process before you will be able to access data ' \
                          'generated by Swedish Universities. If you are not a Swedish citizen or affiliated ' \
                          'with a Swedish university, do not check this box.'

_PURPOSE_HELP_TEXT = 'Please provide a brief description of the purpose for the account, e.g. what type of data you ' \
                     'are interested in.'


def _get_logout_and_reverification_response(request):
    user = request.user

    adapter = get_adapter(request)
    adapter.add_message(
        request, messages.WARNING, "account/messages/logged_out.txt"
    )
    adapter.logout(request)

    # The "perform_login()" flow will trigger the email verification phase.
    return perform_login(request, user, settings.ACCOUNT_EMAIL_VERIFICATION)


def maybe_reset_email_verification_for_user(user):
    email_address = EmailAddress.objects.get_primary(user)
    verification_needed = not user.profile.email_reverification_disabled

    if verification_needed and email_address.verified:
        expiration_period = settings.EMAIL_VERIFICATION_EXPIRATION_PERIOD
        now = datetime.now()
        email_verification_date = user.profile.email_verification_date

        if email_verification_date is None or (now - email_verification_date) >= expiration_period:
            email_address.verified = False
            email_address.save()
            return True

    return False


def maybe_reset_email_verification(email_str):
    """
    Checks if the provided email address is verified, and if so, if the verification was sufficiently recent.
    The EMAIL_VERIFICATION_EXPIRATION_PERIOD setting controls how long an email verification lasts.
    """
    users = EmailAddress.objects.get_users_for(email=email_str)

    if len(users) == 1:
        return maybe_reset_email_verification_for_user(users[0])

    return False


def update_email_verification_date(user):
    """
    Sets the email verification date to now(). This needs to be done as soon as the verification has taken place.
    """
    user.profile.email_verification_date = datetime.now()
    user.profile.save()


def _should_not_challenge_verification_for_request(request):
    return any(filter(request.path.startswith, _EXCLUDED_VERIFICATION_PATHS))


class EmailVerificationChallengeMiddleware(MiddlewareMixin):
    """
    Middleware that tests existing email verifications to see if they are too old. If the primary email verification
    for the current user has expired this middleware will intercept the request, force a logout and start the
    verification phase again.
    """

    def process_request(self, request):
        if _should_not_challenge_verification_for_request(request):
            return

        check_date = request.session.get(_EMAIL_VERIFICATION_CHECK_DATE_KEY)
        check_date = datetime.fromtimestamp(check_date) if check_date else None

        now = datetime.now()
        expiration_date = now + settings.EMAIL_VERIFICATION_CHECK_PERIOD

        if request.user.is_authenticated and (check_date is None or check_date < expiration_date):
            request.session[_EMAIL_VERIFICATION_CHECK_DATE_KEY] = now.timestamp()

            if maybe_reset_email_verification_for_user(request.user):
                return _get_logout_and_reverification_response(request)


class EmailVerificationEnforcingLoginForm(LoginForm):
    """
    Specialized login form that also enforces a recent email verification in order to timely
    request a new verification phase.
    """

    def login(self, request, redirect_url=None):
        email = self.user_credentials().get("email")
        maybe_reset_email_verification(email)
        return super().login(request, redirect_url)


class ExtendedSignupForm(SignupForm):
    field_order = ['email', 'password1', 'password2', 'first_name', 'last_name', 'affiliation', 'purpose',
                   'swedish_user']

    def save(self, request):
        user = super().save(request)

        user.profile.affiliation = self.cleaned_data.get('affiliation')
        user.profile.purpose = self.cleaned_data.get('purpose')
        user.profile.save()

        return user

    first_name = forms.CharField(required=True, widget=forms.TextInput(attrs={
        'placeholder': 'First name'
    }))
    last_name = forms.CharField(required=True, widget=forms.TextInput(attrs={
        'placeholder': 'Last name'
    }))
    affiliation = forms.CharField(required=True, widget=forms.TextInput(attrs={
        'placeholder': 'Affiliation (University or Research center)'
    }))
    purpose = forms.CharField(widget=forms.Textarea(attrs={'rows': 2, 'cols': 20}), help_text=_PURPOSE_HELP_TEXT)

    swedish_user = forms.BooleanField(label='Swedish User', required=False,
                                      help_text=_SWEDISH_USER_HELP_TEXT,
                                      widget=forms.CheckboxInput(attrs={'class': 'form-check-input'}))


class EmailVerificationAccountAdapter(DefaultAccountAdapter):
    def confirm_email(self, request, email_address):
        """
        When an email has been confirmed we add information to the database containing the date of the confirmation.
        """
        super().confirm_email(request, email_address)
        update_email_verification_date(email_address.user)


class EmailEnforcingAccountAdapter(EmailVerificationAccountAdapter):
    def populate_username(self, request, user):
        """
        Fills in a valid username, if required and missing. This overridden function always ensures that the
        """
        from allauth.account.utils import user_field, user_email, user_username
        from allauth.account import app_settings

        first_name = user_field(user, "first_name")
        last_name = user_field(user, "last_name")
        email = user_email(user)
        username = user_email(user)
        if app_settings.USER_MODEL_USERNAME_FIELD:
            user_username(
                user,
                username
                or self.generate_unique_username(
                    [first_name, last_name, email, username, "user"]
                ),
            )
